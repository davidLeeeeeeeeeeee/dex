### address
前10000个共识miner负责执行frost流程

每个miner都能根据状态机和数据库获取前10000miner的公钥（地址）

### withdrew（Frost）
1、聚合者收集参与者的承诺值Ri=>R_agg

2、R_agg发送给所有参与者计算Zi =>聚合者Z_agg

风险点：第一轮的所有参与者，必须保证第二轮发送正确的Si，缺一不可

### withdrew（Roast）
1、所有参与者发送承诺值给聚合者。

2、聚合者选出其中t个Ri发出，获取Ri => R_agg
若失败，再选出t个Ri继续Zi => Z_agg
直到成功。

风险点：聚合者作恶，故意丢失诚实节点签名/超时
应对策略：超时切换聚合者

### design 
1、 要设计好专门接口来拓展不同的链的不同的签名方式，为未来升级以支持不同的链资产作准备。
    
e.g. btc直接聚合公钥地址管理，而智能合约用合约来管理资产，合约管理聚合公钥和验证签名，通过后才放行资产

2、 要设计得尽量去耦，能用接口就用接口定义。

3、 整理需要对外暴露的RPC接口（当前高度下的全网公钥、参与者和聚合者的接口等）

4、 nonce要好好设计，保证异步冗余的情况下，也要保证资金安全，别多签发。

5、 BTC的utxos管理设计好。（检查其他链还需要针对转账设计什么数据结构或模式）

6、 确定第一版要支持这些链的资产：btc\eth\sol\trx\bnb。

7、 这个模块是独立于共识的，会自动从已达成共识的结果（tx）中按队列的方式执行提现、权力交接，就算共识暂停，这个模块服务也不会暂停，会严格执行已达成共识的体现需求。

8、 权力交接是只有前10000个中有2000个已改变（80%）才统一进行，否则搁置。矿工只有等交接完成后才能合理退出挖矿质押。

9、 所以说应该有两个大的独立流程，一个是普通的提现请求，一个是权力交接。

10、要有一个配置文件写各个链(btc\eth\sol\trx\bnb)的手续费 or gasPrice.

11、提现调度：按先到先出原则，即先上账的资金先被提现。

12、forst和整个工程都不需要负责广播三方链的交易，只需要负责签名，把签名结果上链就行。至于交易的广播交给用户手动进行。(提现和权力交接都是这样)

13、因为Roast有可能会产生多笔合法的签名，我目前设想是全部都广播并可以都追加到对应提现tx或权力交接历史中。只需要保证这些签名不会造成双花就行。（我理解只要签名内容一致，就不会双花，不管是智能合约权力交接还是UTXO签名）

14、每一次权力交接都要有dkg过程，而且每个人都需要将自己的承诺点发送tx上链登记，以便私发碎片验证和链上裁决。
### TODO
1、设计稿中就目前而言，有哪些点可能被攻击利用？从而作恶（拖垮运行或威胁资金安全）

2、有没有什么方法可以对网页运行的代码作hash校验，以确保代码一致性，以免误入篡改网站。

3、

### QA
1、随着管理的资产越多（因为每次矿工集合更新的时候，就相当于私钥管理者集合更新），算法（ROAST）复杂度是O(2*n)，如何解决（最主要是保证资产安全，让矿工尽可能参与权力移交）？有什么建议？
答：选用子集合，比如1000个随机矿工作为资产管理地址。

2、需要针对设计权力移交模块，提现模块。好好思考算算复杂度是多少，单机能不能负荷。

3、BTC、eth、sol、trx等权利移交是否可以离线连续进行（即不需要他们native链上数据）？
答：可以，因为都是一个合约统一管理。

4、小额资产呢？有没有必要继续管理维护？
答：btc链小额归集到聚合账户，智能合约用同一个合约管理所有资产即可。

5、权力交接期可能很长，如何确保提现的丝滑呢？

6、gas or 手续费怎么获取？
答：统计每个链一年内的平均手续费，然后以300%的价格写死，下个版本更新。

7、dkg过程 1、保证dealer诚实发出share（被receiver 的公钥加密C = Enc(pk, share; r)） 2、保证receiver 不说谎（2.1 说自己没收到 2.2 收到的是假的）
答：share和承诺一起上链，解决1和2.1. share用receiver公钥加密，当2.2情况出现的时候，dealer公开share明文r,，节点重复加密过程，链上验证裁决.



 我非常理解您的疑惑，这句话我之前的表述确实有些晦涩。我来更直白地解释一下这个**“恶意抢跑”**的场景，以及为什么要加保护。

1. 什么是“恶意抢跑”？
假设我们的 DKG 协议规定如下：

阶段 A (COMMITTING)：大家上传自己的承诺点。
阶段 B (SHARING)：大家上传分发的加密份额。
之前我的修改逻辑是：“只要 VM 看到一笔合法的 ShareTx（阶段 B 的交易），就自动把系统状态改成 SHARING。”

风险在于： 如果节点 1、2 刚发完 Commit，节点 3 还在准备中。此时，**节点 4（恶意节点）**故意提前发出一笔 
ShareTx
。 如果 VM 收到这笔交易就立刻把状态切到 SHARING，那么随后节点 3 的 
CommitTx
 到达 VM 时，就会因为“状态已不是 COMMITTING”而被拒绝掉。

如果这种“抢跑”导致提交 Commit 的人数不足门限 $T$，整轮 DKG 就废了。这就叫恶意终结。

2. “伴随合法的贡献存储”是什么意思？
我当时想表达的是：VM 不能因为看到一个 
ShareTx
 的报文头就切换状态，而必须是：

这笔 
ShareTx
 里的内容（密文）是合法的（确实是委员会成员发的）。
VM 确实把这个密文存进了数据库。
只有当这笔交易实实在在地生效了（产生了贡献），我们才承认状态的自动推进。

3. 更合理的做法：时间窗口（Window）
事实上，最严谨的做法不是靠“谁先发交易”来切状态，而是靠区块高度窗口。

我看了一下代码中 VaultTransitionState 的定义，里面其实有 DkgCommitWindowBlocks。

合理的逻辑应该是：在 TriggerHeight + CommitWindow 之前的区块，VM 必须接受 
Commit
。
目前的现状：为了让您的 Demo 能快速跑通，我们现在的状态机是依靠交易驱动的。
4. 结论：现在的修改破坏协议吗？
结论是：不会破坏安全性（Security），但可能会影响鲁棒性（Robustness）。

安全性没问题：因为即使恶意节点抢跑切了状态，导致 DKG 参与人数不够，最后也绝对生不成合法的 KEY_READY 聚合签名。攻击者最多只能让 DKG 失败重启，拿不到密钥。
鲁棒性有待提升：如果以后发现 DKG 经常因为这种原因失败，我们需要把 VM 的状态切换改为“基于高度”：
高度 < H1：只允许 Commit。
高度 > H1 且 < H2：只允许 Share。
总结： 您现在的代码在功能上是安全的。我之前的解释是为了说明：在“宽容”处理迟到交易的同时，我依然在 VM 里保留了对发送者身份的严格校验，恶意节点无法仅凭伪造一笔垃圾交易就搞乱系统状态。

您可以继续测试，当前的修改已经最大程度保证了在开发调试阶段“不卡死、不分叉”。